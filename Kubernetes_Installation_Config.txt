#Kube-Master(Controller)  - VM 
#	Kube-Worker1
#	Kube-Worker2 

#https://kubernetes.io/docs/setup/
#https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
	
#Add Port: 0 - 65535
#Allow All Traffic for Demo!
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###On Both Master and Worker Nodes:
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sudo -i
apt update -y

#Set the appropriate hostname for each machine.
#-----------------------------------------------
sudo hostnamectl set-hostname "k-master"
exec bash

sudo vi /etc/hosts
172.31.14.67 k-master
#Remember to replace the IPs with those of your systems.
#And only the worker node:
#--------------------------
sudo hostnamectl set-hostname "k-worker1"
exec bash

sudo vi /etc/hosts
172.31.10.44 k-worker1
#Remember to replace the IPs with those of your systems.

sudo hostnamectl set-hostname "k-worker2"
exec bash

sudo vi /etc/hosts
172.31.1.230 k-worker2

#To allow kubelet to work properly, we need to disable swap on both machines.
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab

#Load the br_netfilter module required for networking.
sudo modprobe overlay
sudo modprobe br_netfilter
cat <<EOF | sudo tee /etc/modules-load.d/containerd.conf
overlay
br_netfilter
EOF

#To allow iptables to see bridged traffic, as required by Kubernetes, we need to set the values of certain fields to 1.

sudo tee /etc/sysctl.d/kubernetes.conf<<EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
EOF

#Apply the new settings without restarting.
sudo sysctl --system

#Install curl.
sudo apt-get install -y apt-transport-https ca-certificates curl

#Add the repository key and the repository for kubeadm, kubectl, kubelet.
mkdir /etc/apt/keyrings

#NOTE: Replace the k8s version in below the URLs 
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /" | sudo tee /etc/apt/sources.list.d/kubernetes.list

#Update your system and install the 3 Kubernetes modules along with docker.io.
sudo apt update -y
sudo apt install -y kubelet kubeadm kubectl docker.io
sudo apt-mark hold kubelet kubeadm kubectl docker.io

#Configure Containerd
sudo mkdir /etc/containerd
sudo containerd config default > /etc/containerd/config.toml
sudo sed -i 's/            SystemdCgroup = false/            SystemdCgroup = true/' /etc/containerd/config.toml
sudo systemctl restart containerd
sudo systemctl restart kubelet

#To check that containerd is indeed running, use this command:
ps -ef | grep containerd

#Set up the firewall by installing the following rules on the master/both the nodes:
sudo ufw allow 6443/tcp
sudo ufw allow 2379/tcp
sudo ufw allow 2380/tcp
sudo ufw allow 10250/tcp
sudo ufw allow 10251/tcp
sudo ufw allow 10252/tcp
sudo ufw allow 10255/tcp
sudo ufw reload

#And these rules on the worker/both the nodes:
sudo ufw allow 10251/tcp
sudo ufw allow 10255/tcp
sudo ufw reload



#Finally, enable the kubelet service on both systems so we can start it.
sudo systemctl enable kubelet


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###On Master Node:
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#Step 3. Setting up the cluster
#With our container runtime and Kubernetes modules installed, we are ready to initialize our Kubernetes cluster.

#Run the following command on the master node to allow Kubernetes to fetch the required images before cluster initialization:

sudo kubeadm config images pull

#Initialize the cluster

#sudo kubeadm init --pod-network-cidr=10.244.0.0/16

sudo kubeadm init --pod-network-cidr=10.206.0.0/16 --ignore-preflight-errors=NumCPU --ignore-preflight-errors=Mem

#Check the kubeadm config file (Just FYI)
kubectl -n kube-system get cm kubeadm-config -o yaml
#Check the kubelet config file  (Just FYI)
kubectl -n kube-system get cm kubelet-config -o yaml

#The initialization may take a few moments to finish. Expect an output similar to the following:

#Your Kubernetes control-plane has initialized successfully!
#To start using your cluster, you need to run the following as a regular user:

mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

#Alternatively, if you are the root user, you can run:

#export KUBECONFIG=/etc/kubernetes/admin.conf
#You should now deploy a pod network to the cluster. Run kubectl apply -f [podnetwork].yaml with one of the options listed at Kubernetes.
#Then you can join any number of worker nodes by running the following on each as root:

#kubeadm join 102.130.122.60:6443 --token s3v1c6.dgufsxikpbn9kflf \
        --discovery-token-ca-cert-hash sha256:b8c63b1aba43ba228c9eb63133df81632a07dc780a92ae2bc5ae101ada623e00

#You will see a kubeadm join at the end of the output. Copy and save it in some file. We will have to run this command on the worker node to allow it to join the cluster. If you forget to save it, or misplace it, you can also regenerate it using this command:

#sudo kubeadm token create --print-join-command

#Run below to see that the control plane is not ready, because we have not yet installed CNI
kubectl get nodes -o wide

#Deploy a pod network to our cluster. This is required to interconnect the different Kubernetes components.
#Flannel do not support Network Policy and Ingress
#kubectl apply -f https://github.com/coreos/flannel/raw/master/Documentation/kube-flannel.yml
#Install Calico
	kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/tigera-operator.yaml
	curl https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/custom-resources.yaml -O
	#Edit the yaml to mention our POD network CIDR
	vi custom-resources.yaml
	kubectl create -f custom-resources.yaml

#Use the get nodes command to verify that our master node is ready.
kubectl get nodes -o wide

#Also check whether all the default pods are running:
kubectl get pods --all-namespaces

#We are now ready to move to the worker node. Execute the kubeadm join from step 2 on the worker node. You should see an output similar to the following:

#This node has joined the cluster:
#* Certificate signing request was sent to apiserver and a response was received.
#* The Kubelet was informed of the new secure connection details.
#Run kubectl get nodes on the control-plane to see this node join the cluster.

#If you go back to the master node, you should now be able to see the worker node in the output of the get nodes command.

kubectl get nodes

#And the output should look as follows:

NAME          STATUS   ROLES                  AGE     VERSION
master-node   Ready    control-plane,master   18m40s   v1.24.2
worker-node   Ready    <none>                 3m2s     v1.24.2

#Finally, to set the proper role for the worker node, run this command on the master node:

kubectl label node worker-node node-role.kubernetes.io/worker=worker

#To verify that the role was set:

kubectl get nodes

#The output should show the worker nodeâ€™s role as follows:

NAME          STATUS   ROLES                  AGE     VERSION
master-node   Ready    control-plane,master   5m12s   v1.24.1
worker-node   Ready    worker                 2m55s   v1.24.1


#sudo kubeadm token create --print-join-command

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###Only in Worker Nodes:
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 172.31.14.67:6443 --token 58fyu0.krr84io2uo84ory9 \
        --discovery-token-ca-cert-hash sha256:d41674295c622b18fe641b412753a30c48144a402405a377bf41b74680cd84d0
